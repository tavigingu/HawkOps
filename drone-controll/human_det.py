# YOLOV8 LIVE DETECTION CU CAMERA LAPTOP - STATISTICI OPTIMIZATE
import cv2
import numpy as np
from ultralytics import YOLO
import time

class LivePersonDetector:
    def __init__(self, model_path, conf_threshold=0.3):
        """
        Ini»õializeazƒÉ detectorul live
        
        Args:
            model_path: calea cƒÉtre modelul .pt antrenat
            conf_threshold: pragul de confidence pentru detec»õii
        """
        print("üöÄ Ini»õializez detectorul live...")
        
        # √éncarcƒÉ modelul YOLOv8 antrenat
        try:
            self.model = YOLO(model_path)
            print(f"‚úÖ Model √ÆncƒÉrcat: {model_path}")
        except Exception as e:
            print(f"‚ùå Eroare la √ÆncƒÉrcarea modelului: {e}")
            return
        
        self.conf_threshold = conf_threshold
        self.class_names = ['fallen', 'sit', 'standing']  # Clasele tale
        
        # Culori pentru bounding boxes (BGR format pentru OpenCV)
        self.colors = {
            'fallen': (0, 0, 255),    # Ro»ôu - pericol
            'sit': (0, 255, 255),     # Galben - aten»õie  
            'standing': (0, 255, 0)   # Verde - normal
        }
        
        # Statistici
        self.fps_counter = 0
        self.start_time = time.time()
        self.frame_count = 0
        
    def draw_detection(self, frame, box, class_id, confidence):
        """
        DeseneazƒÉ bounding box »ôi label pe frame
        """
        # Coordonatele bounding box-ului
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        
        # Numele clasei »ôi culoarea
        class_name = self.class_names[class_id] if class_id < len(self.class_names) else f'Class_{class_id}'
        color = self.colors.get(class_name, (255, 255, 255))
        
        # DeseneazƒÉ bounding box
        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
        
        # PregƒÉte»ôte textul
        label = f'{class_name}: {confidence:.2f}'
        label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)[0]
        
        # DeseneazƒÉ background pentru text
        cv2.rectangle(frame, (x1, y1 - label_size[1] - 10), 
                     (x1 + label_size[0], y1), color, -1)
        
        # DeseneazƒÉ textul
        cv2.putText(frame, label, (x1, y1 - 5), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        return frame
    
    def draw_stats_compact(self, frame, detections_count, fps):
        """
        DeseneazƒÉ statistici compacte pe frame (versiune mai micƒÉ)
        """
        height, width = frame.shape[:2]
        
        # Dimensiuni mai mici pentru cadrul de statistici
        stats_width = 180
        stats_height = 60
        margin = 8
        
        # Background semi-transparent pentru statistici
        overlay = frame.copy()
        cv2.rectangle(overlay, (margin, margin), (margin + stats_width, margin + stats_height), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.7, frame, 0.3, 0, frame)
        
        # Border sub»õire
        cv2.rectangle(frame, (margin, margin), (margin + stats_width, margin + stats_height), (100, 100, 100), 1)
        
        # Text mai mic »ôi mai compact
        font_scale = 0.4
        font_thickness = 1
        line_height = 18
        
        # FPS
        cv2.putText(frame, f'FPS: {fps:.1f}', (margin + 5, margin + 15), 
                   cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        
        # Detec»õii
        cv2.putText(frame, f'Det: {detections_count}', (margin + 5, margin + 32), 
                   cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        
        # Confidence
        cv2.putText(frame, f'Conf: {self.conf_threshold:.1f}', (margin + 5, margin + 49), 
                   cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        
        return frame
    
    def draw_stats_minimal(self, frame, detections_count, fps):
        """
        DeseneazƒÉ statistici minimale (doar text, fƒÉrƒÉ background)
        """
        # Text foarte simplu √Æn col»õul din st√¢nga sus
        text = f'FPS:{fps:.0f} Det:{detections_count} Conf:{self.conf_threshold:.1f}'
        
        # Contur negru pentru text (pentru vizibilitate)
        cv2.putText(frame, text, (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)
        # Textul propriu-zis √Æn alb
        cv2.putText(frame, text, (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        return frame
    
    def draw_stats_corner(self, frame, detections_count, fps):
        """
        DeseneazƒÉ statistici √Æn col»õul din dreapta sus
        """
        height, width = frame.shape[:2]
        
        # CalculeazƒÉ dimensiunile textului pentru pozi»õionare
        text_fps = f'FPS: {fps:.1f}'
        text_det = f'Det: {detections_count}'
        text_conf = f'Conf: {self.conf_threshold:.1f}'
        
        font_scale = 0.5
        font_thickness = 1
        
        # Pozi»õionare √Æn col»õul din dreapta sus
        x_pos = width - 120
        y_start = 20
        line_height = 20
        
        # Background semi-transparent mic
        cv2.rectangle(frame, (x_pos - 5, y_start - 15), (width - 5, y_start + 45), (0, 0, 0), -1)
        cv2.rectangle(frame, (x_pos - 5, y_start - 15), (width - 5, y_start + 45), (100, 100, 100), 1)
        
        # DeseneazƒÉ textele
        cv2.putText(frame, text_fps, (x_pos, y_start), cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        cv2.putText(frame, text_det, (x_pos, y_start + line_height), cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        cv2.putText(frame, text_conf, (x_pos, y_start + 2*line_height), cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 255, 0), font_thickness)
        
        return frame
    
    def draw_instructions(self, frame):
        """
        DeseneazƒÉ instruc»õiunile √Æn partea de jos
        """
        height, width = frame.shape[:2]
        cv2.putText(frame, 'Q:quit  +/-:confidence  R:reset  S:switch stats', 
                   (10, height - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)
        return frame
    
    def process_frame(self, frame):
        """
        ProceseazƒÉ un frame »ôi returneazƒÉ frame-ul cu detec»õiile
        """
        # RuleazƒÉ detec»õia
        results = self.model(frame, conf=self.conf_threshold, verbose=False)
        
        detections_count = 0
        
        # ProceseazƒÉ rezultatele
        if len(results) > 0 and len(results[0].boxes) > 0:
            boxes = results[0].boxes
            detections_count = len(boxes)
            
            # DeseneazƒÉ fiecare detec»õie
            for box in boxes:
                class_id = int(box.cls[0])
                confidence = float(box.conf[0])
                frame = self.draw_detection(frame, box, class_id, confidence)
        
        return frame, detections_count
    
    def start_detection(self, camera_id=0, window_size=(1280, 720), stats_mode='compact'):
        """
        Porne»ôte detec»õia live
        
        Args:
            camera_id: ID-ul camerei (0 pentru camera principalƒÉ)
            window_size: dimensiunea ferestrei de afi»ôare
            stats_mode: modul de afi»ôare statistici ('compact', 'minimal', 'corner', 'none')
        """
        print(f"üìπ √éncerc sƒÉ conectez camera {camera_id}...")
        
        # Ini»õializeazƒÉ camera
        cap = cv2.VideoCapture(camera_id)
        
        if not cap.isOpened():
            print("‚ùå Nu pot accesa camera!")
            print("üí° √éncearcƒÉ sƒÉ schimbi camera_id (0, 1, 2...)")
            return
        
        # SeteazƒÉ rezolu»õia camerei
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        cap.set(cv2.CAP_PROP_FPS, 30)
        
        print("‚úÖ Camera conectatƒÉ cu succes!")
        print("\nüéÆ COMENZI:")
        print("  Q - Opre»ôte detec»õia")
        print("  + - Cre»ôte confidence threshold")
        print("  - - Scade confidence threshold")
        print("  R - Reset statistici")
        print("  S - SchimbƒÉ modul de afi»ôare statistici")
        print("\nüöÄ √éncepe detec»õia live...")
        
        # Modurile de afi»ôare statistici
        stats_modes = ['compact', 'minimal', 'corner', 'none']
        current_stats_mode = stats_mode
        
        try:
            while True:
                # Cite»ôte frame-ul
                ret, frame = cap.read()
                if not ret:
                    print("‚ùå Nu pot citi de la camerƒÉ!")
                    break
                
                # ProceseazƒÉ frame-ul
                start_process = time.time()
                processed_frame, detections_count = self.process_frame(frame)
                process_time = time.time() - start_process
                
                # CalculeazƒÉ FPS
                self.frame_count += 1
                elapsed_time = time.time() - self.start_time
                fps = self.frame_count / elapsed_time if elapsed_time > 0 else 0
                
                # DeseneazƒÉ statistici √Æn func»õie de mod
                if current_stats_mode == 'compact':
                    processed_frame = self.draw_stats_compact(processed_frame, detections_count, fps)
                elif current_stats_mode == 'minimal':
                    processed_frame = self.draw_stats_minimal(processed_frame, detections_count, fps)
                elif current_stats_mode == 'corner':
                    processed_frame = self.draw_stats_corner(processed_frame, detections_count, fps)
                # 'none' - nu deseneazƒÉ statistici
                
                # DeseneazƒÉ instruc»õiunile
                processed_frame = self.draw_instructions(processed_frame)
                
                # RedimensioneazƒÉ pentru afi»ôare
                processed_frame = cv2.resize(processed_frame, window_size)
                
                # Afi»ôeazƒÉ frame-ul
                cv2.imshow('YOLOv8 Live Person Detection', processed_frame)
                
                # VerificƒÉ taste apƒÉsate
                key = cv2.waitKey(1) & 0xFF
                
                if key == ord('q') or key == ord('Q'):
                    print("üõë Opresc detec»õia...")
                    break
                elif key == ord('+') or key == ord('='):
                    self.conf_threshold = min(0.9, self.conf_threshold + 0.1)
                    print(f"üìà Confidence threshold: {self.conf_threshold:.1f}")
                elif key == ord('-') or key == ord('_'):
                    self.conf_threshold = max(0.1, self.conf_threshold - 0.1)
                    print(f"üìâ Confidence threshold: {self.conf_threshold:.1f}")
                elif key == ord('r') or key == ord('R'):
                    self.frame_count = 0
                    self.start_time = time.time()
                    print("üîÑ Statistici resetate")
                elif key == ord('s') or key == ord('S'):
                    # SchimbƒÉ modul de statistici
                    current_index = stats_modes.index(current_stats_mode)
                    current_stats_mode = stats_modes[(current_index + 1) % len(stats_modes)]
                    print(f"üìä Mod statistici: {current_stats_mode}")
                
        except KeyboardInterrupt:
            print("\nüõë √éntrerupt de utilizator")
        
        finally:
            # Cleanup
            cap.release()
            cv2.destroyAllWindows()
            print("‚úÖ Camera √ÆnchisƒÉ »ôi resurse eliberate")
            
            # Statistici finale
            total_time = time.time() - self.start_time
            avg_fps = self.frame_count / total_time if total_time > 0 else 0
            print(f"\nüìä STATISTICI FINALE:")
            print(f"   ‚Ä¢ Total frame-uri: {self.frame_count}")
            print(f"   ‚Ä¢ Timp total: {total_time:.1f}s")
            print(f"   ‚Ä¢ FPS mediu: {avg_fps:.1f}")

def main():
    """Func»õia principalƒÉ pentru a rula detectorul live"""
    
    # Calea cƒÉtre modelul tƒÉu antrenat
    MODEL_PATH = "best.pt"  # SchimbƒÉ cu calea ta
    
    # VerificƒÉ dacƒÉ modelul existƒÉ
    import os
    if not os.path.exists(MODEL_PATH):
        print(f"‚ùå Modelul nu existƒÉ la: {MODEL_PATH}")
        print("üí° AsigurƒÉ-te cƒÉ ai copiat fi»ôierul best.pt √Æn directorul curent")
        print("üí° Sau schimbƒÉ MODEL_PATH cu calea corectƒÉ")
        return
    
    # CreeazƒÉ detectorul
    detector = LivePersonDetector(
        model_path=MODEL_PATH,
        conf_threshold=0.3  # AjusteazƒÉ dupƒÉ nevoie
    )
    
    # Porne»ôte detec»õia live
    # Op»õiuni pentru stats_mode: 'compact', 'minimal', 'corner', 'none'
    detector.start_detection(
        camera_id=0,  # SchimbƒÉ cu 1, 2, etc. dacƒÉ nu func»õioneazƒÉ
        window_size=(1280, 720),  # Dimensiunea ferestrei
        stats_mode='compact'  # SchimbƒÉ cu 'minimal', 'corner', sau 'none'
    )

if __name__ == "__main__":
    main()